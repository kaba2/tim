Delay embedding
===============

[[Parent]]: tim_core.txt

Theory
------

Let ''S : ZZ -> RR^n'' be an ''n''-dimensional signal.

### Delay-embedding

A _delay-embedding_ of ''S'' is a signal 
''R : ZZ -> RR^(kn)'' such that 

''R(t) = (
(S(t - (k - 1) Delta t))
(...), 
(S(t - Delta t)), 
(S(t)))''

where
 
 * ''Delta t in ZZ'' is the _embedding delay_.
 
 * ''k in ZZ'' is the _embedding factor_.
 
 * ''kn'' is the _embedding dimension_.
 
A specific delay-embedding can be identified with the 
pair ''(Delta t, k)''.

### Future of a signal

The _future_ of the signal ''S'' under a given 
delay-embedding ''(Delta t, k)'' is given by
the signal ''Q : ZZ -> RR^n'' such that

''Q(t) = S(t + Delta t)''

Practice
--------

You might notice that we do not allow for embedding shift,
i.e. translation of the signal before delay-embedding.
This is deliberate, since this way the time instant zero
keeps associated to the first element of the embedded signal.
The time shifting is done in the estimators via the lag 
parameters.

In practice the signals are only defined on a bounded support. 
In TIM the signals are extended to the whole domain by padding them
with NaNs. The result is that there are NaNs in the beginning of 
each delay-embedded signal. These NaNs in the beginning are virtually
clipped away in the estimators and replaced with additional lags.
For example, in TIM Matlab:

	>> A = delay_embed([1, 2, 3, 4], 3, 1);
	>> [B, lag] = delay_embed([1, 2, 3, 4], 3, 1, 'compact');
	
Yields:

	A = NaN NaN 1 2 
	    NaN   1 2 3 
	      1   2 3 4
	      
	B = 1 2
	    2 3
	    3 4
	    
Computing

	>> differential_entropy_kl(A);
	>> differential_entropy_kl(B);

Yields the same results. The same applies to other estimators, if only
one remembers to apply the additional lag:

	>> mutual_information(A, A);
	>> mutual_information(A, B, 0, lag);

	
	    
	     
	

